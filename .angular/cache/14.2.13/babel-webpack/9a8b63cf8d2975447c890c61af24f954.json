{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/loich/Dev/Repos/playlistify/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/loich/Dev/Repos/playlistify/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/loich/Dev/Repos/playlistify/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Album } from '../../models/album.model';\nimport { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';\nimport { of, Subject } from 'rxjs';\nimport { catchError, map, tap } from 'rxjs/operators';\nimport { LocalEndPoints } from './localAPIEndpoints';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./localAPIEndpoints\";\nexport var AlbumService = /*#__PURE__*/(function () {\n  var AlbumService = /*#__PURE__*/function () {\n    function AlbumService(http, localEndPoints) {\n      _classCallCheck(this, AlbumService);\n\n      this.http = http;\n      this.localEndPoints = localEndPoints; // albumUrl = `/api/albums`;\n\n      this.albumChanged = new Subject();\n    }\n\n    _createClass(AlbumService, [{\n      key: \"updateAlbumOnDB\",\n      value: function updateAlbumOnDB(album) {\n        // console.log(JSON.stringify(Album));\n        var httpOptions = {\n          headers: new HttpHeaders({\n            'Content-Type': 'application/json'\n          })\n        };\n        return this.http.put(this.localEndPoints.albumEndPoint, album, httpOptions).pipe(tap(function (_) {\n          return console.log('update album');\n        }), catchError(this.handleError('updateAlbum')), map(function (res) {\n          return res['data'];\n        }));\n      }\n    }, {\n      key: \"getAlbums\",\n      value: function getAlbums(page, limit) {\n        var _this = this;\n\n        var httpParams = new HttpParams().set('page', page.toString());\n        httpParams.append('limit', limit.toString());\n        return this.http.get(this.localEndPoints.albumEndPoint, {\n          params: httpParams\n        }).pipe(map(function (res) {\n          return _this.retrieveResponseData(res);\n        }));\n      }\n    }, {\n      key: \"retrieveResponseData\",\n      value: function retrieveResponseData(res) {\n        var albums = new Array();\n\n        var _iterator = _createForOfIteratorHelper(res['data'].docs),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var album = _step.value;\n            albums.push(new Album(album._id, album.artistName, album.albumName, album.sputnikMusic, album.heavyBIsH, album.hasOwnProperty('spotify') ? album.spotify : null, album.yourLastRites));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var albumsListI = {\n          albumsList: albums,\n          totalNumberOfAlbums: res['data'].totalDocs,\n          currentPage: res['data'].page,\n          totalNumberOfPages: res['data'].totalPages\n        };\n        return albumsListI;\n      }\n    }, {\n      key: \"updateAlbum\",\n      value: function updateAlbum(index, album) {\n        this.albumChanged.next({\n          index: index,\n          album: album\n        });\n      }\n    }, {\n      key: \"savePlaylistAlbum\",\n      value: function savePlaylistAlbum(item) {\n        return this.http.post(this.localEndPoints.playlistifiedAlbumsEndPoint, {\n          params: {\n            playlist: item\n          }\n        }).pipe(map(function (resp) {\n          return resp['data'];\n        })); // .map( response => {});\n      }\n    }, {\n      key: \"searchPlaylistifiedAlbums\",\n      value: function searchPlaylistifiedAlbums(albums, userId) {\n        var albumIds = [];\n        albums.forEach(function (album) {\n          albumIds.push(album._id);\n        });\n        return this.http.get(this.localEndPoints.playlistifiedAlbumsEndPoint, {\n          params: {\n            userId: userId,\n            albumId: albumIds\n          }\n        }).pipe(map(function (resp) {\n          // console.log(resp['data']);\n          if (resp != null) {\n            return resp['data'];\n          } else {\n            return null;\n          }\n        }));\n      }\n    }, {\n      key: \"searchAlbum\",\n      value: function searchAlbum(searchItem, scope, searchSources, page, limit) {\n        var _this2 = this;\n\n        console.log(searchItem); // if(searchItem != (null || \"\")){\n\n        return this.http.get(this.localEndPoints.searchEndPoint, {\n          params: {\n            q: searchItem,\n            scope: scope,\n            sources: searchSources,\n            page: page.toString(),\n            limit: limit.toString()\n          }\n        } // return null;\n        ).pipe(map(function (response) {\n          console.log(response);\n\n          if (response['data'] != null) {\n            return _this2.retrieveResponseData(response); // return response['data'];\n          } else {\n            return of({});\n          }\n        })); // }\n        // return of({});\n      }\n      /**\n         * Handle Http operation that failed.\n         * Let the app continue.\n         * @param operation - name of the operation that failed\n         * @param result - optional value to return as the observable result\n         */\n\n    }, {\n      key: \"handleError\",\n      value: function handleError() {\n        var _this3 = this;\n\n        var operation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'operation';\n        var result = arguments.length > 1 ? arguments[1] : undefined;\n        return function (error) {\n          // TODO: send the error to remote logging infrastructure\n          console.error(error); // log to console instead\n          // TODO: better job of transforming error for user consumption\n\n          _this3.log(\"\".concat(operation, \" failed: \").concat(error.message)); // Let the app keep running by returning an empty result.\n\n\n          return of(result);\n        };\n      }\n      /** Log a HeroService message with the MessageService */\n\n    }, {\n      key: \"log\",\n      value: function log(message) {\n        this.messageService.add(\"Album update: \".concat(message));\n      }\n    }]);\n\n    return AlbumService;\n  }();\n\n  AlbumService.ɵfac = function AlbumService_Factory(t) {\n    return new (t || AlbumService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.LocalEndPoints));\n  };\n\n  AlbumService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AlbumService,\n    factory: AlbumService.ɵfac\n  });\n  return AlbumService;\n})();","map":null,"metadata":{},"sourceType":"module"}