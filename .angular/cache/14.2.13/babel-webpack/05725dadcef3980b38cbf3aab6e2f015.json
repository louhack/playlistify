{"ast":null,"code":"import _defineProperty from \"/Users/loich/Dev/Repos/playlistify/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/loich/Dev/Repos/playlistify/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/loich/Dev/Repos/playlistify/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Directive, ViewContainerRef, Input, Injectable, ɵɵdefineInjectable, Component, Renderer2, ElementRef, HostBinding, EventEmitter, Output, TemplateRef, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction TabsetComponent_li_1_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r6 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"span\", 7);\n    ɵngcc0.ɵɵlistener(\"click\", function TabsetComponent_li_1_span_4_Template_span_click_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r6);\n      var tabz_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n      var ctx_r4 = ɵngcc0.ɵɵnextContext();\n      $event.preventDefault();\n      return ɵngcc0.ɵɵresetView(ctx_r4.removeTab(tabz_r1));\n    });\n    ɵngcc0.ɵɵtext(1, \" \\u274C\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nvar _c0 = function _c0(a1) {\n  return [\"nav-item\", a1];\n};\n\nfunction TabsetComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r8 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 3);\n    ɵngcc0.ɵɵlistener(\"keydown\", function TabsetComponent_li_1_Template_li_keydown_0_listener($event) {\n      var restoredCtx = ɵngcc0.ɵɵrestoreView(_r8);\n      var i_r2 = restoredCtx.index;\n      var ctx_r7 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r7.keyNavActions($event, i_r2));\n    });\n    ɵngcc0.ɵɵelementStart(1, \"a\", 4);\n    ɵngcc0.ɵɵlistener(\"click\", function TabsetComponent_li_1_Template_a_click_1_listener() {\n      var restoredCtx = ɵngcc0.ɵɵrestoreView(_r8);\n      var tabz_r1 = restoredCtx.$implicit;\n      return ɵngcc0.ɵɵresetView(tabz_r1.active = true);\n    });\n    ɵngcc0.ɵɵelementStart(2, \"span\", 5);\n    ɵngcc0.ɵɵtext(3);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(4, TabsetComponent_li_1_span_4_Template, 2, 0, \"span\", 6);\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    var tabz_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"active\", tabz_r1.active)(\"disabled\", tabz_r1.disabled);\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(15, _c0, tabz_r1.customClass || \"\"));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"active\", tabz_r1.active)(\"disabled\", tabz_r1.disabled);\n    ɵngcc0.ɵɵattribute(\"aria-controls\", tabz_r1.id ? tabz_r1.id : \"\")(\"aria-selected\", !!tabz_r1.active)(\"id\", tabz_r1.id ? tabz_r1.id + \"-link\" : \"\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTransclude\", tabz_r1.headingRef);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(tabz_r1.heading);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", tabz_r1.removable);\n  }\n}\n\nvar _c1 = [\"*\"];\nvar NgTranscludeDirective = /*#__PURE__*/(function () {\n  var NgTranscludeDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} viewRef\n     */\n    function NgTranscludeDirective(viewRef) {\n      _classCallCheck(this, NgTranscludeDirective);\n\n      this.viewRef = viewRef;\n    }\n    /**\n     * @param {?} templateRef\n     * @return {?}\n     */\n\n\n    _createClass(NgTranscludeDirective, [{\n      key: \"ngTransclude\",\n      get:\n      /* tslint:disable-next-line:no-any */\n\n      /**\n       * @return {?}\n       */\n      function get() {\n        return this._ngTransclude;\n      },\n      set: function set(templateRef) {\n        this._ngTransclude = templateRef;\n\n        if (templateRef) {\n          this.viewRef.createEmbeddedView(templateRef);\n        }\n      }\n    }]);\n\n    return NgTranscludeDirective;\n  }();\n\n  NgTranscludeDirective.ɵfac = function NgTranscludeDirective_Factory(t) {\n    return new (t || NgTranscludeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  NgTranscludeDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NgTranscludeDirective,\n    selectors: [[\"\", \"ngTransclude\", \"\"]],\n    inputs: {\n      ngTransclude: \"ngTransclude\"\n    }\n  });\n  /** @nocollapse */\n\n  return NgTranscludeDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  NgTranscludeDirective.prototype.viewRef;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  NgTranscludeDirective.prototype._viewRef;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  NgTranscludeDirective.prototype._ngTransclude;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar TabsetConfig = /*#__PURE__*/(function () {\n  var TabsetConfig = /*#__PURE__*/_createClass(function TabsetConfig() {\n    _classCallCheck(this, TabsetConfig);\n\n    /**\n     * provides default navigation context class: 'tabs' or 'pills'\n     */\n    this.type = 'tabs';\n    /**\n     * provides possibility to set keyNavigations enable or disable, by default is enable\n     */\n\n    this.isKeysAllowed = true;\n    /**\n     * aria label for tab list\n     */\n\n    this.ariaLabel = 'Tabs';\n  });\n\n  TabsetConfig.ɵfac = function TabsetConfig_Factory(t) {\n    return new (t || TabsetConfig)();\n  };\n  /** @nocollapse */\n\n\n  TabsetConfig.ɵprov = ɵɵdefineInjectable({\n    factory: function TabsetConfig_Factory() {\n      return new TabsetConfig();\n    },\n    token: TabsetConfig,\n    providedIn: \"root\"\n  });\n  return TabsetConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * provides default navigation context class: 'tabs' or 'pills'\n   * @type {?}\n   */\n  TabsetConfig.prototype.type;\n  /**\n   * provides possibility to set keyNavigations enable or disable, by default is enable\n   * @type {?}\n   */\n\n  TabsetConfig.prototype.isKeysAllowed;\n  /**\n   * aria label for tab list\n   * @type {?}\n   */\n\n  TabsetConfig.prototype.ariaLabel;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// todo: add active event to tab\n// todo: fix? mixing static and dynamic tabs position tabs in order of creation\n\n\nvar TabsetComponent = /*#__PURE__*/(function () {\n  var TabsetComponent = /*#__PURE__*/function () {\n    /**\n     * @param {?} config\n     * @param {?} renderer\n     * @param {?} elementRef\n     */\n    function TabsetComponent(config, renderer, elementRef) {\n      _classCallCheck(this, TabsetComponent);\n\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.clazz = true;\n      this.tabs = [];\n      this.classMap = {};\n      Object.assign(this, config);\n    }\n    /**\n     * if true tabs will be placed vertically\n     * @return {?}\n     */\n\n\n    _createClass(TabsetComponent, [{\n      key: \"vertical\",\n      get: function get() {\n        return this._vertical;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._vertical = value;\n        this.setClassMap();\n      }\n      /**\n       * if true tabs fill the container and have a consistent width\n       * @return {?}\n       */\n\n    }, {\n      key: \"justified\",\n      get: function get() {\n        return this._justified;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._justified = value;\n        this.setClassMap();\n      }\n      /**\n       * navigation context class: 'tabs' or 'pills'\n       * @return {?}\n       */\n\n    }, {\n      key: \"type\",\n      get: function get() {\n        return this._type;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._type = value;\n        this.setClassMap();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isKeysAllowed\",\n      get: function get() {\n        return this._isKeysAllowed;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._isKeysAllowed = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.isDestroyed = true;\n      }\n      /**\n       * @param {?} tab\n       * @return {?}\n       */\n\n    }, {\n      key: \"addTab\",\n      value: function addTab(tab) {\n        this.tabs.push(tab);\n        tab.active = this.tabs.length === 1 && typeof tab.active === 'undefined';\n      }\n      /**\n       * @param {?} tab\n       * @param {?=} options\n       * @return {?}\n       */\n\n    }, {\n      key: \"removeTab\",\n      value: function removeTab(tab) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          reselect: true,\n          emit: true\n        };\n\n        /** @type {?} */\n        var index = this.tabs.indexOf(tab);\n\n        if (index === -1 || this.isDestroyed) {\n          return;\n        } // Select a new tab if the tab to be removed is selected and not destroyed\n\n\n        if (options.reselect && tab.active && this.hasAvailableTabs(index)) {\n          /** @type {?} */\n          var newActiveIndex = this.getClosestTabIndex(index);\n          this.tabs[newActiveIndex].active = true;\n        }\n\n        if (options.emit) {\n          tab.removed.emit(tab);\n        }\n\n        this.tabs.splice(index, 1);\n\n        if (tab.elementRef.nativeElement.parentNode) {\n          this.renderer.removeChild(tab.elementRef.nativeElement.parentNode, tab.elementRef.nativeElement);\n        }\n      }\n      /* tslint:disable-next-line: cyclomatic-complexity */\n\n      /**\n       * @param {?} event\n       * @param {?} index\n       * @return {?}\n       */\n\n    }, {\n      key: \"keyNavActions\",\n      value: function keyNavActions(event, index) {\n        if (!this.isKeysAllowed) {\n          return;\n        }\n        /** @type {?} */\n\n\n        var list = Array.from(this.elementRef.nativeElement.querySelectorAll('.nav-link')); // const activeElList = list.filter((el: HTMLElement) => !el.classList.contains('disabled'));\n        // tslint:disable-next-line:deprecation\n\n        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n          event.preventDefault();\n          /** @type {?} */\n\n          var currentTab = list[index % list.length];\n          currentTab.click();\n          return;\n        } // tslint:disable-next-line:deprecation\n\n\n        if (event.keyCode === 39 || event.key === 'RightArrow') {\n          /** @type {?} */\n          var nextTab;\n          /** @type {?} */\n\n          var shift = 1;\n\n          do {\n            nextTab = list[(index + shift) % list.length];\n            shift++;\n          } while (nextTab.classList.contains('disabled'));\n\n          nextTab.focus();\n          return;\n        } // tslint:disable-next-line:deprecation\n\n\n        if (event.keyCode === 37 || event.key === 'LeftArrow') {\n          /** @type {?} */\n          var previousTab;\n          /** @type {?} */\n\n          var _shift = 1;\n          /** @type {?} */\n\n          var i = index;\n\n          do {\n            if (i - _shift < 0) {\n              i = list.length - 1;\n              previousTab = list[i];\n              _shift = 0;\n            } else {\n              previousTab = list[i - _shift];\n            }\n\n            _shift++;\n          } while (previousTab.classList.contains('disabled'));\n\n          previousTab.focus();\n          return;\n        } // tslint:disable-next-line:deprecation\n\n\n        if (event.keyCode === 36 || event.key === 'Home') {\n          event.preventDefault();\n          /** @type {?} */\n\n          var firstTab;\n          /** @type {?} */\n\n          var _shift2 = 0;\n\n          do {\n            firstTab = list[_shift2 % list.length];\n            _shift2++;\n          } while (firstTab.classList.contains('disabled'));\n\n          firstTab.focus();\n          return;\n        } // tslint:disable-next-line:deprecation\n\n\n        if (event.keyCode === 35 || event.key === 'End') {\n          event.preventDefault();\n          /** @type {?} */\n\n          var lastTab;\n          /** @type {?} */\n\n          var _shift3 = 1;\n          /** @type {?} */\n\n          var _i = index;\n\n          do {\n            if (_i - _shift3 < 0) {\n              _i = list.length - 1;\n              lastTab = list[_i];\n              _shift3 = 0;\n            } else {\n              lastTab = list[_i - _shift3];\n            }\n\n            _shift3++;\n          } while (lastTab.classList.contains('disabled'));\n\n          lastTab.focus();\n          return;\n        } // tslint:disable-next-line:deprecation\n\n\n        if (event.keyCode === 46 || event.key === 'Delete') {\n          if (this.tabs[index].removable) {\n            this.removeTab(this.tabs[index]);\n\n            if (list[index + 1]) {\n              list[(index + 1) % list.length].focus();\n              return;\n            }\n\n            if (list[list.length - 1]) {\n              list[0].focus();\n            }\n          }\n        }\n      }\n      /**\n       * @protected\n       * @param {?} index\n       * @return {?}\n       */\n\n    }, {\n      key: \"getClosestTabIndex\",\n      value: function getClosestTabIndex(index) {\n        /** @type {?} */\n        var tabsLength = this.tabs.length;\n\n        if (!tabsLength) {\n          return -1;\n        }\n\n        for (var step = 1; step <= tabsLength; step += 1) {\n          /** @type {?} */\n          var prevIndex = index - step;\n          /** @type {?} */\n\n          var nextIndex = index + step;\n\n          if (this.tabs[prevIndex] && !this.tabs[prevIndex].disabled) {\n            return prevIndex;\n          }\n\n          if (this.tabs[nextIndex] && !this.tabs[nextIndex].disabled) {\n            return nextIndex;\n          }\n        }\n\n        return -1;\n      }\n      /**\n       * @protected\n       * @param {?} index\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasAvailableTabs\",\n      value: function hasAvailableTabs(index) {\n        /** @type {?} */\n        var tabsLength = this.tabs.length;\n\n        if (!tabsLength) {\n          return false;\n        }\n\n        for (var i = 0; i < tabsLength; i += 1) {\n          if (!this.tabs[i].disabled && i !== index) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /**\n       * @protected\n       * @return {?}\n       */\n\n    }, {\n      key: \"setClassMap\",\n      value: function setClassMap() {\n        this.classMap = _defineProperty({\n          'nav-stacked': this.vertical,\n          'flex-column': this.vertical,\n          'nav-justified': this.justified\n        }, \"nav-\".concat(this.type), true);\n      }\n    }]);\n\n    return TabsetComponent;\n  }();\n\n  TabsetComponent.ɵfac = function TabsetComponent_Factory(t) {\n    return new (t || TabsetComponent)(ɵngcc0.ɵɵdirectiveInject(TabsetConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  TabsetComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TabsetComponent,\n    selectors: [[\"tabset\"]],\n    hostVars: 2,\n    hostBindings: function TabsetComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"tab-container\", ctx.clazz);\n      }\n    },\n    inputs: {\n      vertical: \"vertical\",\n      justified: \"justified\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 3,\n    consts: [[\"role\", \"tablist\", 1, \"nav\", 3, \"ngClass\", \"click\"], [3, \"ngClass\", \"active\", \"disabled\", \"keydown\", 4, \"ngFor\", \"ngForOf\"], [1, \"tab-content\"], [3, \"ngClass\", \"keydown\"], [\"href\", \"javascript:void(0);\", \"role\", \"tab\", 1, \"nav-link\", 3, \"click\"], [3, \"ngTransclude\"], [\"class\", \"bs-remove-tab\", 3, \"click\", 4, \"ngIf\"], [1, \"bs-remove-tab\", 3, \"click\"]],\n    template: function TabsetComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"ul\", 0);\n        ɵngcc0.ɵɵlistener(\"click\", function TabsetComponent_Template_ul_click_0_listener($event) {\n          return $event.preventDefault();\n        });\n        ɵngcc0.ɵɵtemplate(1, TabsetComponent_li_1_Template, 5, 17, \"li\", 1);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.classMap);\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.ariaLabel);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.tabs);\n      }\n    },\n    dependencies: [ɵngcc1.NgClass, ɵngcc1.NgForOf, ɵngcc1.NgIf, NgTranscludeDirective],\n    styles: [\"[_nghost-%COMP%]   .nav-tabs[_ngcontent-%COMP%]   .nav-item.disabled[_ngcontent-%COMP%]   a.disabled[_ngcontent-%COMP%]{cursor:default}\"]\n  });\n  /** @nocollapse */\n\n  return TabsetComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  TabsetComponent.prototype.clazz;\n  /** @type {?} */\n\n  TabsetComponent.prototype.tabs;\n  /** @type {?} */\n\n  TabsetComponent.prototype.classMap;\n  /**\n   * aria label for tab list\n   * @type {?}\n   */\n\n  TabsetComponent.prototype.ariaLabel;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  TabsetComponent.prototype.isDestroyed;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  TabsetComponent.prototype._vertical;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  TabsetComponent.prototype._justified;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  TabsetComponent.prototype._type;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  TabsetComponent.prototype._isKeysAllowed;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TabsetComponent.prototype.renderer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TabsetComponent.prototype.elementRef;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar TabDirective = /*#__PURE__*/(function () {\n  var TabDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} tabset\n     * @param {?} elementRef\n     * @param {?} renderer\n     */\n    function TabDirective(tabset, elementRef, renderer) {\n      _classCallCheck(this, TabDirective);\n\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      /**\n       * fired when tab became active, $event:Tab equals to selected instance of Tab component\n       */\n\n      this.selectTab = new EventEmitter();\n      /**\n       * fired when tab became inactive, $event:Tab equals to deselected instance of Tab component\n       */\n\n      this.deselect = new EventEmitter();\n      /**\n       * fired before tab will be removed, $event:Tab equals to instance of removed tab\n       */\n\n      this.removed = new EventEmitter();\n      this.addClass = true;\n      this.role = 'tabpanel';\n      this.tabset = tabset;\n      this.tabset.addTab(this);\n    }\n    /**\n     * if set, will be added to the tab's class attribute. Multiple classes are supported.\n     * @return {?}\n     */\n\n\n    _createClass(TabDirective, [{\n      key: \"customClass\",\n      get: function get() {\n        return this._customClass;\n      }\n      /**\n       * @param {?} customClass\n       * @return {?}\n       */\n      ,\n      set: function set(customClass) {\n        var _this = this;\n\n        if (this.customClass) {\n          this.customClass.split(' ').forEach(\n          /**\n          * @param {?} cssClass\n          * @return {?}\n          */\n          function (cssClass) {\n            _this.renderer.removeClass(_this.elementRef.nativeElement, cssClass);\n          });\n        }\n\n        this._customClass = customClass ? customClass.trim() : null;\n\n        if (this.customClass) {\n          this.customClass.split(' ').forEach(\n          /**\n          * @param {?} cssClass\n          * @return {?}\n          */\n          function (cssClass) {\n            _this.renderer.addClass(_this.elementRef.nativeElement, cssClass);\n          });\n        }\n      }\n      /**\n       * tab active state toggle\n       * @return {?}\n       */\n\n    }, {\n      key: \"active\",\n      get: function get() {\n        return this._active;\n      }\n      /**\n       * @param {?} active\n       * @return {?}\n       */\n      ,\n      set: function set(active) {\n        var _this2 = this;\n\n        if (this._active === active) {\n          return;\n        }\n\n        if (this.disabled && active || !active) {\n          if (this._active && !active) {\n            this.deselect.emit(this);\n            this._active = active;\n          }\n\n          return;\n        }\n\n        this._active = active;\n        this.selectTab.emit(this);\n        this.tabset.tabs.forEach(\n        /**\n        * @param {?} tab\n        * @return {?}\n        */\n        function (tab) {\n          if (tab !== _this2) {\n            tab.active = false;\n          }\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ariaLabelledby\",\n      get: function get() {\n        return this.id ? \"\".concat(this.id, \"-link\") : '';\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.removable = this.removable;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.tabset.removeTab(this, {\n          reselect: false,\n          emit: false\n        });\n      }\n    }]);\n\n    return TabDirective;\n  }();\n\n  TabDirective.ɵfac = function TabDirective_Factory(t) {\n    return new (t || TabDirective)(ɵngcc0.ɵɵdirectiveInject(TabsetComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  TabDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TabDirective,\n    selectors: [[\"tab\"], [\"\", \"tab\", \"\"]],\n    hostVars: 7,\n    hostBindings: function TabDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"aria-labelledby\", ctx.ariaLabelledby)(\"id\", ctx.id);\n        ɵngcc0.ɵɵclassProp(\"tab-pane\", ctx.addClass)(\"active\", ctx.active);\n      }\n    },\n    inputs: {\n      customClass: \"customClass\",\n      active: \"active\",\n      removable: \"removable\",\n      heading: \"heading\",\n      id: \"id\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      selectTab: \"selectTab\",\n      deselect: \"deselect\",\n      removed: \"removed\"\n    },\n    exportAs: [\"tab\"]\n  });\n  /** @nocollapse */\n\n  return TabDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * tab header text\n   * @type {?}\n   */\n  TabDirective.prototype.heading;\n  /**\n   * tab id. The same id with suffix '-link' will be added to the corresponding &lt;li&gt; element\n   * @type {?}\n   */\n\n  TabDirective.prototype.id;\n  /**\n   * if true tab can not be activated\n   * @type {?}\n   */\n\n  TabDirective.prototype.disabled;\n  /**\n   * if true tab can be removable, additional button will appear\n   * @type {?}\n   */\n\n  TabDirective.prototype.removable;\n  /**\n   * fired when tab became active, $event:Tab equals to selected instance of Tab component\n   * @type {?}\n   */\n\n  TabDirective.prototype.selectTab;\n  /**\n   * fired when tab became inactive, $event:Tab equals to deselected instance of Tab component\n   * @type {?}\n   */\n\n  TabDirective.prototype.deselect;\n  /**\n   * fired before tab will be removed, $event:Tab equals to instance of removed tab\n   * @type {?}\n   */\n\n  TabDirective.prototype.removed;\n  /** @type {?} */\n\n  TabDirective.prototype.addClass;\n  /** @type {?} */\n\n  TabDirective.prototype.role;\n  /** @type {?} */\n\n  TabDirective.prototype.headingRef;\n  /** @type {?} */\n\n  TabDirective.prototype.tabset;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  TabDirective.prototype._active;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  TabDirective.prototype._customClass;\n  /** @type {?} */\n\n  TabDirective.prototype.elementRef;\n  /** @type {?} */\n\n  TabDirective.prototype.renderer;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Should be used to mark <ng-template> element as a template for tab heading\n */\n\n\nvar TabHeadingDirective = /*#__PURE__*/(function () {\n  var TabHeadingDirective = /*#__PURE__*/_createClass(\n  /* tslint:disable-next-line:no-any */\n\n  /**\n   * @param {?} templateRef\n   * @param {?} tab\n   */\n  function TabHeadingDirective(templateRef, tab) {\n    _classCallCheck(this, TabHeadingDirective);\n\n    tab.headingRef = templateRef;\n  });\n\n  TabHeadingDirective.ɵfac = function TabHeadingDirective_Factory(t) {\n    return new (t || TabHeadingDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(TabDirective));\n  };\n\n  TabHeadingDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TabHeadingDirective,\n    selectors: [[\"\", \"tabHeading\", \"\"]]\n  });\n  /** @nocollapse */\n\n  return TabHeadingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  TabHeadingDirective.prototype.templateRef;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar TabsModule = /*#__PURE__*/(function () {\n  var TabsModule = /*#__PURE__*/function () {\n    function TabsModule() {\n      _classCallCheck(this, TabsModule);\n    }\n\n    _createClass(TabsModule, null, [{\n      key: \"forRoot\",\n      value:\n      /**\n       * @return {?}\n       */\n      function forRoot() {\n        return {\n          ngModule: TabsModule,\n          providers: []\n        };\n      }\n    }]);\n\n    return TabsModule;\n  }();\n\n  TabsModule.ɵfac = function TabsModule_Factory(t) {\n    return new (t || TabsModule)();\n  };\n\n  TabsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TabsModule\n  });\n  TabsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return TabsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabsModule, {\n    declarations: function declarations() {\n      return [NgTranscludeDirective, TabDirective, TabsetComponent, TabHeadingDirective];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [TabDirective, TabsetComponent, TabHeadingDirective, NgTranscludeDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { NgTranscludeDirective, TabDirective, TabHeadingDirective, TabsModule, TabsetComponent, TabsetConfig }; //# sourceMappingURL=ngx-bootstrap-tabs.js.map","map":null,"metadata":{},"sourceType":"module"}